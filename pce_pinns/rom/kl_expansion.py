""" 
Karhunen-Loeve Expansion
Author: 
"""
import numpy as np
import pce_pinns.utils.plotting as plotting

def kl_expansion(xgrid, mu_y, cov, kl_dim=3, z_candidate=None, plot=True):
    """
    Applies karhunen-loeve expansion to a stochastic process in 1D
    Assumes the stochastic process is a Gaussian Process (GP) with given mean and covariance

    Args:
        xgrid np.array(n_grid): 1D grid points
        mu_y np.array(n_grid): Computed mean values of stochastic process on grid
        cov np.array(n_grid, n_grid): Computed covariance function of stochastic process on grid
        kl_dim int: Number of non-truncated eigenvalues for Karhunen-Loeve expansion
        z_candidate np.array(kl_dim): If not None, these are candidates for the new random variables
    
    Returns:
        Y np.array(n_grid): Sample of the apprximated stochastic process 
        kl_trunc_err float: KL truncation error
        eigvals_major np.array((kl_dim)): Major eigenvalues of the cov matrix
        eigvecs_major np.array((n_grid, kl_dim)): Major eigenvectors of the cov matrix
        z np.array(kl_dim): Used random instances of KL expansion
        sample_kl fn(np.array((n_grid,kl_dim)): Function to quickly query KL-expansion for new z  
    """
    n_grid = xgrid.shape[0]

    # Compute covariance eigenvalues and truncate
    eigvals, eigvecs = np.linalg.eig(cov) # eig s are returned sorted 
    eigvals_major = eigvals[:kl_dim]
    eigvecs_major = eigvecs[:, :kl_dim] #eigvecs[:kl_dim,:].T#
    
    # Function to quickly query KL-expansion for new z
    def sample_kl(kl_dim=kl_dim):
        # Sample new random variable
        if z_candidate is None:
            # Assume Y is generated by Gaussian Process
            # Wrong: z = np.random.normal(0., 1., (n_grid, kl_dim))
            # Wrong: z = np.random.normal(0., 1.) * np.ones((n_grid,kl_dim)) # , kl_dim)[np.newaxis,:], repeats=n_grid, axis=0)
            z = np.repeat(np.random.normal(0., 1., kl_dim)[np.newaxis,:], repeats=n_grid, axis=0)
        else:
            z = np.repeat(z_candidate[np.newaxis,:], repeats=n_grid, axis=0)

        y_sample = mu_y + np.matmul(np.multiply(eigvecs[:,:kl_dim], z), np.sqrt(eigvals[:kl_dim]))
        exp_y_sample = np.exp(y_sample)
        return y_sample, exp_y_sample, z

    Y, exp_Y, z = sample_kl()
    #kl_fn = lambda z_vec: mu_y + np.matmul(np.multiply(eigvecs_major, z_vec), np.sqrt(eigvals_major))

    # Compute new stochastic process at z
    #Y = mu_y + np.matmul(np.multiply(eigvecs_major, z), np.sqrt(eigvals_major))

    # Compute KL truncation error
    kl_trunc_err = np.sum(eigvals[kl_dim:])

    if plot:
        plotting.plot_kl_expansion(xgrid, Y, kl_dim, eigvals, eigvecs, sample_kl)

    return Y, exp_Y, kl_trunc_err, eigvals_major, eigvecs_major, z, sample_kl
